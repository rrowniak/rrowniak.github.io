<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>gdb na Linuksie czyli jak ujarzmić swój kod | Rafal’s blog</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="gdb na Linuksie czyli jak ujarzmić swój kod" />
<meta name="author" content="Rafał Równiak" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="gdb jest chyba najbardziej przerażającym narzędziem dla początkujących programistów, a jeśli dodać, że najczęściej w naturze występuje na systemach Linux to niejedna tęga głowa dostaje palpitacji serca. Ale jeśli kodujesz w C lub C++ na systemy Linuksowe to niestety jesteś skazany na ten debugger. Ale nie taki diabeł straszny jak go malują. Zobaczmy na przykładzie jak korzystać z tego narzędzia…" />
<meta property="og:description" content="gdb jest chyba najbardziej przerażającym narzędziem dla początkujących programistów, a jeśli dodać, że najczęściej w naturze występuje na systemach Linux to niejedna tęga głowa dostaje palpitacji serca. Ale jeśli kodujesz w C lub C++ na systemy Linuksowe to niestety jesteś skazany na ten debugger. Ale nie taki diabeł straszny jak go malują. Zobaczmy na przykładzie jak korzystać z tego narzędzia…" />
<link rel="canonical" href="/_posts/programming/gdb-na-linuksie-czyli-jak-ujarzmic-swoj-kod/" />
<meta property="og:url" content="/_posts/programming/gdb-na-linuksie-czyli-jak-ujarzmic-swoj-kod/" />
<meta property="og:site_name" content="Rafal’s blog" />
<meta property="og:image" content="/_posts/wp-content/uploads/2019/01/mohsen-bagherzadeh-451137-small.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-27T11:33:43+01:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/_posts/wp-content/uploads/2019/01/mohsen-bagherzadeh-451137-small.jpg" />
<meta property="twitter:title" content="gdb na Linuksie czyli jak ujarzmić swój kod" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Rafał Równiak"},"dateModified":"2019-01-27T11:33:43+01:00","datePublished":"2019-01-27T11:33:43+01:00","description":"gdb jest chyba najbardziej przerażającym narzędziem dla początkujących programistów, a jeśli dodać, że najczęściej w naturze występuje na systemach Linux to niejedna tęga głowa dostaje palpitacji serca. Ale jeśli kodujesz w C lub C++ na systemy Linuksowe to niestety jesteś skazany na ten debugger. Ale nie taki diabeł straszny jak go malują. Zobaczmy na przykładzie jak korzystać z tego narzędzia…","headline":"gdb na Linuksie czyli jak ujarzmić swój kod","image":"/_posts/wp-content/uploads/2019/01/mohsen-bagherzadeh-451137-small.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"/_posts/programming/gdb-na-linuksie-czyli-jak-ujarzmic-swoj-kod/"},"url":"/_posts/programming/gdb-na-linuksie-czyli-jak-ujarzmic-swoj-kod/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/_posts/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/_posts/feed.xml" title="Rafal&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/_posts/">Rafal&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/_posts/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">gdb na Linuksie czyli jak ujarzmić swój kod</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-01-27T11:33:43+01:00" itemprop="datePublished">Jan 27, 2019
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Rafał Równiak</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><code class="language-plaintext highlighter-rouge">gdb</code> jest chyba najbardziej przerażającym narzędziem dla początkujących programistów, a jeśli dodać, że najczęściej w naturze występuje na systemach Linux to niejedna tęga głowa dostaje palpitacji serca. Ale jeśli kodujesz w C lub C++ na systemy Linuksowe to niestety jesteś skazany na ten debugger. Ale nie taki diabeł straszny jak go malują. Zobaczmy na przykładzie jak korzystać z tego narzędzia…</p>

<p><code class="language-plaintext highlighter-rouge">gdb</code> jest debuggerem pracującym w trybie tekstowym, czyli nie ma trybu graficznego gdzie moglibyśmy sobie klikać i oglądać ładne okienka. Jednak nie jest to w żaden sposób ograniczające, wręcz przeciwnie – <code class="language-plaintext highlighter-rouge">gdb</code>to bardzo potężne narzędzie, chyba najbardziej rozbudowany debugger. I wiele środowisk programistycznych pod spodem wykorzystuje właśnie ten debugger. Są również graficzne nakładki. My jednak będziemy zapoznawać się z <code class="language-plaintext highlighter-rouge">gdb</code>bez używania takich dobrodziejstw.</p>

<h2 id="przykład">Przykład</h2>

<p>Zaczniemy od przykładu, programu, który będzie wyświetlał prędkość zadanego rdzenia CPU, z błędami na potrzeby naszych ćwiczeń oczywiście. Dla przykładu:</p>

<p><code class="language-plaintext highlighter-rouge">$ ./cpu_speed 2</code></p>

<p>zwróci nam wynik:</p>

<p><code class="language-plaintext highlighter-rouge">799.980 MHz</code></p>

<p>A oto pierwsza próba zaimplementowania tego programu (wszystkie wersje można znaleźć na <a href="https://github.com/rrowniak/blog/tree/master/gdb-exercise">moim githubie</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;pre class="wp-block-code"&gt;```c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

const char filename[] = "/proc/cpuinfo";
const char cpu_section[] = "processor\t: %d";
const char speed_tag[] = "cpu MHz\t\t: ";

static int is_cpu_section(const char* section_line, const char* curr_line) {
    do {
        if (*section_line == '\0') {
            return 1;
        }
    } while (curr_line != '\0' &amp;&amp; *section_line == *curr_line);
    return 0;
}

static const char* extract_mhz(const char* line)
{
    const char* str = NULL;
    if ((str = strstr(line, speed_tag)) != NULL) {
        str += strlen(speed_tag);
    }
    return str;
} 

static void scan_file(FILE *f, const char* cpu_section_num)
{
    char* line = NULL;
    size_t len = 0;
    ssize_t read;
    int section_found = 0;
    const char* mhz = NULL; 

    while ((read = getline(&amp;line, &amp;len, f)) != -1) {
        if (!section_found &amp;&amp; !is_cpu_section(cpu_section_num, line)) {
            section_found = 1;
            continue;
        }

        if ((mhz = extract_mhz(line)) != NULL) {
            printf("%s MHz", mhz);
            break;
        }
    }

    if (line) {
        free(line);
    }
}

int main(int argc, char const *argv[])
{
    FILE* f = NULL;
    int core_num;
    char cpu_section_num[255];

    if (argc &lt; 2) {
        fprintf(stderr, "usage: cpu_speed &lt;cpu_num&gt;\n");
        exit(EXIT_FAILURE);
    }

    core_num = atoi(argv[1]);
    sprintf(cpu_section_num, cpu_section, core_num);

    scan_file(f, cpu_section_num);

    fclose(f);
    return EXIT_SUCCESS;
}
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Kod oczywiście kompilujemy:

`$ gcc -o2 cpu_speed-v1.c -o cpu_speed-v1`

i uruchamiamy. Niestety rezultat jest trochę inny niż ten oczekiwany:

`$ ./cpu_speed-v1 3&lt;br&gt;&lt;/br&gt; Segmentation fault (core dumped)`

W skrócie można powiedzieć, że `Segmentation fault` to błąd dostępu do pamięci, odwołujemy się pod adres, który (z różnych powodów) jest dla nas niedostępny. I co teraz? Można oczywiście wrzucić kod na jakieś forum np. [tutaj](https://4programmers.net/) i liczyć, że jakaś pomocna dusza znajdzie rozwiązanie problemu. Ale szczerze mówiąc – nie wypada, a przynajmniej nie wypada aby samemu nie spróbować zdiagnozować usterki. I tu do akcji wkracza `gdb`.

## Pierwszy krok – start `gdb`

Odpalmy więc naszego odpluskwiacza poleceniem:

`$ gdb ./cpu_speed`

Zostaniemy przywitani konsolą `gdb`, nasze pierwsze polecenie to uruchomienie programu z argumentem: `run 2`. Jako rezultat dostaniemy coś takiego:

</code></pre></div></div>
<pre class="wp-block-code">```
(gdb) run 1
Starting program: /home/rr/tmp/cpu_speed-v1 1

Program received signal SIGSEGV, Segmentation fault.
_IO_getdelim (lineptr=0x7fffffffdc18, n=0x7fffffffdc20, delimiter=10, fp=0x0) at iogetdelim.c:52
52	iogetdelim.c: No such file or directory.
```
```

No cóż, póki co nie wiele nam to mówi, ale możemy wyczytać, że nasz program otrzymał sygnał `SIGSEV`co właśnie oznacza `Segmentation fault`, mamy adresy pewnych zmiennych i ostrzeżenie, że nie można otworzyć pewnego pliku. Ten plik to część biblioteki standardowej C więc można podejrzewać, że tam został naruszony dostęp do pamięci. Ale nie oznacza to, że tam jest błąd, najprawdopodobniej to my przekazaliśmy złe argumenty do jakiejś funkcji z biblioteki C. Aby to zrobić musimy sprawdzić stos wywołań (*call stack*) poleceniem `bt` co jest skrótem od *backtrace*

```
<pre class="wp-block-code">```
(gdb) bt
#0  _IO_getdelim (lineptr=0x7fffffffdc18, n=0x7fffffffdc20, delimiter=10, fp=0x0) at iogetdelim.c:52
#1  0x000000000040093b in scan_file ()
#2  0x0000000000400a29 in main ()
```
```

Widzimy, że w całą kabałę jest zamieszana funkcja `scan_file`ale przecież nie wywołujemy nic takiego jak `_IO_getdelim`, o co więc chodzi? Możemy przyjrzeć się bliżej co się dzieje w `scan_file`zmieniając aktywną ramkę numer 0 na numer 1 (odpowiada funkcji `scan_file`) poleceniem `f 1` (`f`to skrót od *frame*):

```
<pre class="wp-block-code">```
(gdb) f 1
#1  0x000000000040093b in scan_file ()
```
```

i spróbujmy zapytać debugger o konkretną linię kodu poleceniem `l`(*list*):

```
<pre class="wp-block-code">```
(gdb) l
47	in iogetdelim.c
```
```

Hmm…

## Kompilacja w trybie *debug*

Coś jest nie tak. Taki potężny debugger, a nie dostaliśmy żadnych wartościowych danych? Okazuje się, że jest to bardzo częsta pułapka, w którą wpadają początkujący adepci sztuki programowania. Problemem nie jest debugger, tylko sposób w jaki skompilowaliśmy naszą aplikację – użyliśmy opcji `-o2`nakazując naszemu kompilatorowi wykonanie agresywnych optymalizacji. A trzeba wiedzieć, że debugger potrzebuje dodatkowych informacji, pewnych metadanych zaszytych w pliku wykonywalnym aby móc dostarczyć nam więcej szczegółów. Więc trzeba powiedzieć naszemu kompilatorowi aby umieścił te informacje – robimy to poleceniem `-g`. Wyłączymy również agresywne optymalizacje aby nie doświadczać potencjalnie dziwnych zachowań podczas debugowania (np. brak zmienny lokalnych, brak pewnych wywołań itp.). A i chyba najważniejsze polecenie – z `gdb`wychodzimy poleceniem `q`. Więc kompilujemy od nowa:

`gcc -g cpu_speed-v1.c -o cpu_speed-v1_debug`

I ponawiamy nasze eksperymenty. Polecenie `bt`jest już o wiele bardziej przydatne:

```
<pre class="wp-block-code">```
(gdb) bt
#0  _IO_getdelim (lineptr=0x7fffffffdc08, n=0x7fffffffdc10, delimiter=10, fp=0x0) at iogetdelim.c:52
#1  0x000000000040093b in scan_file (f=0x0, cpu_section_num=0x7fffffffdc60 "processor\t: 1") at cpu_speed-v1.c:35
#2  0x0000000000400a29 in main (argc=2, argv=0x7fffffffde58) at cpu_speed-v1.c:66
```
```

Wiemy już, że problem jest w *cpu\_speed-v1.c,* linia 35, niech debugger pokaże więcej szczegółów:

```
<pre class="wp-block-code">```
(gdb) f 1
#1  0x000000000040093b in scan_file (f=0x0, cpu_section_num=0x7fffffffdc60 "processor\t: 1") at cpu_speed-v1.c:35
35	    while ((read = getline(&amp;line, &amp;len, f)) != -1) {
```
```

Aha, tu jest problem, ale jaki dokładnie? Może czas na podejrzenie wartości zmiennych? Nic trudnego, polecenie `p`jest do tego stworzone:

```
<pre class="wp-block-code">```
(gdb) p line
$1 = 0x0
(gdb) p len
$2 = 0
(gdb) p f
$3 = (FILE *) 0x0
```
```

Zmienna `line`i `len`mogą przyjmować takie wartości podczas pierwszej iteracji pętli `while`ale `f`nie może przyjmować wartości `0`czyli `NULL`! Więc robimy przegląd kodu i co się okazuje? Przecież wskaźnik `f`jest tylko inicjowany a brakuje funkcji `fopen()`! Co za błąd, ja biorę się za poprawianie a tymczasem zobaczmy czego już się nauczyliśmy:

## Ściąga

<div class="wp-block-advgb-list">- `gdb ./nazwa_programu`– rozpoczęcie sesji debuggera
- `run argument_1 argument_2 ...`– uruchomienie naszego programu pod kontrolą debuggera
- `bt`– wyświetlenie aktualnego stosu wywołań (*callstack*)
- `f mumer_ramki`– wybór aktywnej ramki (funkcji w stosie wywołań)
- `p nazwa_zmiennej`– wypisanie wartości danej zmiennej. Uwaga – zmienna musi być widoczna w danym bloku (*scope*)
- `l`– zobacz bieżącą linijkę i sąsiadujący kod
- `q`– tym poleceniem wychodzimy z debuggera (kończymy sesję)
- Aby debuggowanie było łatwe i przyjemne należy skompilować kod jako *debug* czyli w `gcc`dodajemy opcję `-g`

<style>.advgblist-041b7e80-3aad-408d-b963-7186202dd0d8 li { font-size: 16px; margin-left: 20px }</style><style>.advgblist-041b7e80-3aad-408d-b963-7186202dd0d8 li:before {
                            font-size: 16px;
                            color: #000;
                            line-height: 18px;
                            margin: 2px;
                            padding: 2px;
                            margin-left: -22px;
                        }</style></div>## Tryb krokowy

Kod poprawiony, poniższa wstawka dodana:

```
<pre class="wp-block-code">```c
    if ((f = fopen(filename, "r")) == NULL) {
        fprintf(stderr, "can't open %s file", filename);
        exit(EXIT_FAILURE);
    }
```
```

Kompilujemy i testujemy… I znowu coś nie jest w porządku! Tym razem nasz program uruchamia się i nie chce zakończyć działania. Podejrzewamy pętlę nieskończoną. Odpalmy sesję `gdb`w taki sam sposób jak poprzednio. I dziwna sytuacja – `gdb` nie daje nam interaktywnej konsoli. Czyżby debugger również się zapętlił? Na szczęście nie. Uruchomiliśmy program, a `gdb`nie widzi potrzeby jago przerywania (bo np. nie ma sygnału `SIGSEV`). Więc musimy zrobić to sami poleceniem `Ctrl + C`:

```
<pre class="wp-block-code">```
(gdb) run 1
Starting program: /home/rr/tmp/cpu_speed-v2_debug 1
^C
Program received signal SIGINT, Interrupt.
0x00000000004008d2 in is_cpu_section (section_line=0x7fffffffdc60 "processor\t: 1", curr_line=0x602240 "processor\t: 0\n") at cpu_speed-v2.c:14
14	    } while (curr_line != '\0' &amp;&amp; *section_line == *curr_line);
(gdb) bt
#0  0x00000000004008d2 in is_cpu_section (section_line=0x7fffffffdc60 "processor\t: 1", curr_line=0x602240 "processor\t: 0\n") at cpu_speed-v2.c:14
#1  0x0000000000400978 in scan_file (f=0x602010, cpu_section_num=0x7fffffffdc60 "processor\t: 1") at cpu_speed-v2.c:36
#2  0x0000000000400b01 in main (argc=2, argv=0x7fffffffde58) at cpu_speed-v2.c:71
```
```

Widzimy, że kombinacja `Ctrl + C`wygenerowała sygnał `SIGINT`(*interrupt*) i to spowodowało zatrzymanie naszego programu i przejście do interaktywnej sesji. Od razu wyświetliłem stos wywołań poleceniem `bt`i widzimy, że łańcuch wywołań to `main`-&gt; `scan_file`-&gt; `is_cpu_section`a w środku tej ostatniej funkcji mamy pętlę `do-while`. I właśnie tutaj zaczynamy podejrzewać, że coś jest nie tak. Możemy spróbować przeanalizować kod lub skorzystać z jeszcze innej możliwości. A mianowicie chcielibyśmy przeanalizować jak do tego doszło, że warunki wyjścia z pętli nigdy nie są spełnione. Spróbujemy przeanalizować działanie naszego programu w sposób krokowy, linia za linią. Ale aby to zrobić musimy ustawić pułapkę, czyli miejsce w którym debugger automatycznie się zatrzyma abyśmy mogli ręcznie kontynuować wykonanie programu. Do tego służą tzw. *breakpoint’y*. Ustawmy się taki przed wywołaniem funkcji `is_cpu_section`– chodzi oczywiście o plik *cpu\_speed-v2.c* linię 36. Do tego służy polecenie `b`:

```
<pre class="wp-block-code">```
(gdb) b cpu_speed-v2.c:36
Breakpoint 1 at 0x40095f: file cpu_speed-v2.c, line 36.
```
```

I ponownie uruchommy nasz program poleceniem `run 2`:

```
<pre class="wp-block-code">```
(gdb) run 2
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/rr/tmp/cpu_speed-v2_debug 2

Breakpoint 1, scan_file (f=0x602010, cpu_section_num=0x7fffffffdc60 "processor\t: 2") at cpu_speed-v2.c:36
36	        if (!section_found &amp;&amp; !is_cpu_section(cpu_section_num, line)) {
```
```

Świetnie, nasza pułapka zadziałała więc teraz możemy przeglądać zmienne i krokowo kontynuować działanie programu, do tego mamy trzy polecenia:

<div class="wp-block-advgb-list">- `n`– wykonaj bieżącą linię (polecenie)
- `s`– wejdź do funkcji jeśli takie wywołanie jest w bieżącej linii
- `c`– wyjdź z trybu manualnego i kontynuuj działanie programu (aż do następnej pułapki bądź `Ctrl + C`)

<style>.advgblist-debaed5f-f9de-491a-bb69-bd05f7a862ae li { font-size: 16px; margin-left: 20px }</style></div>Tutaj można zobaczyć te polecenia w akcji:

```
<pre class="wp-block-code">```
(gdb) s
is_cpu_section (section_line=0x7fffffffdc60 "processor\t: 2", curr_line=0x602240 "processor\t: 0\n") at cpu_speed-v2.c:11
11	        if (*section_line == '\0') {
(gdb) n
14	    } while (curr_line != '\0' &amp;&amp; *section_line == *curr_line);
(gdb) p *section_line
$1 = 112 'p'
(gdb) p *curr_line
$2 = 112 'p'
(gdb) n
11	        if (*section_line == '\0') {
(gdb) n
14	    } while (curr_line != '\0' &amp;&amp; *section_line == *curr_line);
(gdb) p *section_line
$3 = 112 'p'
(gdb) p *curr_line
$4 = 112 'p'
```
```

Widać wyraźnie, że podczas dwóch iteracji pętli `do-while`wskaźniki `section_line`i `curr_line`nadal wskazują na te same wartości! Czyli warunek zawsze będzie ten sam! Mamy kolejny błąd. Poprawmy go zatem na:

```
<pre class="wp-block-code">```c
static int is_cpu_section(const char* section_line, const char* curr_line) {
    do {
        if (*section_line == '\0') {
            return 1;
        }
    } while (curr_line != '\0' &amp;&amp; *section_line++ == *curr_line++);
    return 0;
}
```
```

Zdecydowanie lepiej. Program działa:

```
<pre class="wp-block-code">```
$ ./cpu_speed-v3_debug 3
810.632
 MHz
```
```

Chociaż tekst nie jest idealnie złożony, gdzieś pojawiło się niepotrzebne złamanie linii… Ale ten problem już zostawiam jako zadanie domowe.

## Co udało się omówić?

- [Przykład](#advgb-toc-24c8a292-4116-40cc-8ce8-55b00f8e9519)
- [Pierwszy krok – start gdb](#advgb-toc-37bdb69d-6878-4702-bf56-e71bdc2016fe)
- [Kompilacja w trybie debug](#advgb-toc-448e4f80-2913-4063-ba81-544c6878d156)
- [Ściąga](#advgb-toc-c88e8b58-9f51-485c-a93b-b1789b801d05)
- [Tryb krokowy](#advgb-toc-ab9448ec-51fe-4c1c-93f1-477f936b9e3c)
- [Co udało się omówić?](#advgb-toc-7f5fa526-04eb-406d-ab69-39fedc2b9ccb)
</pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre>

  </div><a class="u-url" href="/_posts/programming/gdb-na-linuksie-czyli-jak-ujarzmic-swoj-kod/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/_posts/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Rafal&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Rafal&#39;s blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/rrowniak"><svg class="svg-icon"><use xlink:href="/_posts/assets/minima-social-icons.svg#github"></use></svg> <span class="username">rrowniak</span></a></li><li><a href="https://www.twitter.com/rrowniak"><svg class="svg-icon"><use xlink:href="/_posts/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">rrowniak</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my IT blog! Here, you will find articles on a wide range of topics related to technology and computer science.  My blog covers everything from software architecture and programming languages like C++ to performance optimization and Linux systems.  Whether you&#39;re a seasoned IT professional or just starting out in the field, I hope you&#39;ll find something of interest on my blog.  Follow me to stay up to date with the latest trends and best practices in the world of technology.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
